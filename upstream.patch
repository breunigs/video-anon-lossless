From 8756a1428419d34d3f325fd3ed160ca62ad906b3 Mon Sep 17 00:00:00 2001
From: Stefan Breunig <stefan-github@yrden.de>
Date: Sat, 10 Apr 2021 16:53:39 +0200
Subject: [PATCH] hack it together

---
 anonymizer/anonymization/anonymizer.py | 210 ++++++++++++++++++++++---
 anonymizer/bin/anonymize.py            |  59 ++++---
 anonymizer/detection/detector.py       |   8 +-
 requirements.txt                       |   4 +-
 4 files changed, 228 insertions(+), 53 deletions(-)

diff --git a/anonymizer/anonymization/anonymizer.py b/anonymizer/anonymization/anonymizer.py
index 5f113d1..3547e02 100644
--- a/anonymizer/anonymization/anonymizer.py
+++ b/anonymizer/anonymization/anonymizer.py
@@ -1,14 +1,36 @@
-import json
-from pathlib import Path
-
-import numpy as np
-from PIL import Image
+from anonymizer.utils import Box
+from subprocess import Popen, PIPE, STDOUT
+import imageio.plugins.ffmpeg
+import imageio
 from tqdm import tqdm
+from PIL import Image, ExifTags
+import numpy as np
+from pathlib import Path
+import json
+import sys
+import tempfile
+import io
+import tarfile
+from shutil import rmtree
+import threading
+import signal
 
 
 def load_np_image(image_path):
-    image = Image.open(image_path).convert('RGB')
-    np_image = np.array(image)
+    image = Image.open(image_path)
+    try:
+        exif = dict((ExifTags.TAGS[k], v) for k, v in image._getexif().items() if k in ExifTags.TAGS)
+        print(image._getexif().items())
+        if exif['Orientation'] == 3:
+            image = image.rotate(180, expand=True)
+        elif exif['Orientation'] == 6:
+            image = image.rotate(270, expand=True)
+        elif exif['Orientation'] == 8:
+            image = image.rotate(90, expand=True)
+    except:
+        print(f"probably not a jpg: {image_path}")
+
+    np_image = np.array(image.convert('RGB'))
     return np_image
 
 
@@ -32,10 +54,67 @@ def save_detections(detections, detections_path):
         json.dump(json_output, output_file, indent=2)
 
 
+def load_detections(detections_path):
+    with open(detections_path, 'r') as detection_file:
+        data = detection_file.read()
+
+    boxes = []
+    for box in json.loads(data):
+        boxes.append(Box(y_min=box['y_min'], x_min=box['x_min'],
+                         y_max=box['y_max'], x_max=box['x_max'],
+                         score=box['score'], kind=box['kind']))
+    return boxes
+
+
+def blur_with_imagemagick(image, detections):
+    if len(detections) == 0:
+        return image
+
+    cmd = ['convert']
+    for box in detections:
+        for extra, blur in {0: "0x15", 2: "0x4", 4: "0x2", 7: "0x1"}.items():
+            x = box.x_min - extra
+            y = box.y_min - extra
+            w = box.x_max + extra - x
+            h = box.y_max + extra - y
+
+            cmd.extend(['-region', f'{w}x{h}+{x}+{y}', '-blur', blur])
+    cmd.extend(['-', '-'])
+
+    pil_image = Image.fromarray((image).astype(np.uint8), mode='RGB')
+    with io.BytesIO() as buff:
+        pil_image.save(buff, format="BMP")
+
+        p = Popen(cmd, stdout=PIPE, stdin=PIPE, stderr=PIPE)
+        bmp, stderr = p.communicate(input=buff.getvalue())
+
+    if len(stderr) > 0:
+        print(str(stderr))
+    assert len(stderr) == 0, 'ImageMagick did not succeed blurring. Is it installed?'
+
+    image = Image.open(io.BytesIO(bmp)).convert('RGB')
+    np_image = np.array(image)
+
+    return np_image
+
+
 class Anonymizer:
     def __init__(self, detectors, obfuscator):
         self.detectors = detectors
         self.obfuscator = obfuscator
+        self.need_to_shutdown = False
+
+        signal.signal(signal.SIGINT, self.shutdown)
+        signal.signal(signal.SIGTERM, self.shutdown)
+
+    def shutdown(self, signum, frame):
+        print("\nTrying to shutdown gracefully...")
+        self.need_to_shutdown = True
+
+    def blur(self, image, detections):
+        if self.obfuscator != None:
+            return self.obfuscator.obfuscate(image, detections)
+        return blur_with_imagemagick(image, detections)
 
     def anonymize_image(self, image, detection_thresholds):
         assert set(self.detectors.keys()) == set(detection_thresholds.keys()),\
@@ -44,28 +123,113 @@ def anonymize_image(self, image, detection_thresholds):
         for kind, detector in self.detectors.items():
             new_boxes = detector.detect(image, detection_threshold=detection_thresholds[kind])
             detected_boxes.extend(new_boxes)
-        return self.obfuscator.obfuscate(image, detected_boxes), detected_boxes
+        return detected_boxes
+
+    def anonymize_video(self, video_in, detection_thresholds, video_out, json_out_path):
+        reader: imageio.plugins.ffmpeg.FfmpegFormat.Reader = imageio.get_reader(video_in)
+        meta = reader.get_meta_data()
+        _ = meta['size']
+        read_iter = reader.iter_data()
+        nframes = reader.count_frames()
+
+        writer: imageio.plugins.ffmpeg.FfmpegFormat.Writer = imageio.get_writer(
+            video_out, format='FFMPEG', mode='I', fps=meta['fps'], codec="ffv1",
+            quality=None, output_params=["-movflags", "frag_keyframe+empty_moov"])
+
+        bar = tqdm(dynamic_ncols=True, total=nframes, position=1, leave=True, desc=video_in.name)
+
+        thrJsonSaver = None
+        thrVideoWriter = None
+        for index, frame in enumerate(read_iter):
+            output_detections_path = json_out_path / f"{index}.json"
+            if (output_detections_path).exists():
+                detections = load_detections(detections_path=str(output_detections_path))
+            else:
+                detections = self.anonymize_image(image=frame, detection_thresholds=detection_thresholds)
+
+                if thrJsonSaver != None:
+                    thrJsonSaver.join()
+                thrJsonSaver = threading.Thread(target=save_detections, kwargs=dict(
+                    detections=detections,
+                    detections_path=str(output_detections_path)
+                ))
+                thrJsonSaver.start()
+
+            if self.need_to_shutdown:
+                break
+
+            frame = self.blur(frame, detections)
+
+            if thrVideoWriter != None:
+                thrVideoWriter.join()
+            thrVideoWriter = threading.Thread(target=writer.append_data, args=[frame])
+            thrVideoWriter.start()
 
-    def anonymize_images(self, input_path, output_path, detection_thresholds, file_types, write_json):
-        print(f'Anonymizing images in {input_path} and saving the anonymized images to {output_path}...')
+            bar.update()
 
-        Path(output_path).mkdir(exist_ok=True)
-        assert Path(output_path).is_dir(), 'Output path must be a directory'
+        if thrJsonSaver != None:
+            thrJsonSaver.join()
+        if thrVideoWriter != None:
+            thrVideoWriter.join()
+        writer.close()
+        bar.close()
 
+    def filter_files(self, all_files, file_types, suffix):
         files = []
-        for file_type in file_types:
-            files.extend(list(Path(input_path).glob(f'**/*.{file_type}')))
+        for file in all_files.keys():
+            if file.endswith(suffix):
+                continue
+            if file+suffix in all_files:
+                continue
+            if not any(file.endswith(f'.{x}') for x in file_types):
+                continue
+            files.append(Path(file))
+        return files
 
-        for input_image_path in tqdm(files):
-            # Create output directory
-            relative_path = input_image_path.relative_to(input_path)
-            (Path(output_path) / relative_path.parent).mkdir(exist_ok=True, parents=True)
-            output_image_path = Path(output_path) / relative_path
-            output_detections_path = (Path(output_path) / relative_path).with_suffix('.json')
+    def anonymize_videos(self, input_path, detection_thresholds, all_files, file_types, write_json):
+        files = self.filter_files(all_files, file_types, ".anonymized.mkv")
+
+        for video in tqdm(files, desc="Videos"):
+            video_out_path = video.with_name(f"{video.name}.anonymized.mkv")
+            json_out_path = video.with_name(f'{video.name}_jsons')
+            json_out_path.mkdir(parents=True, exist_ok=True)
+
+            with tempfile.TemporaryDirectory(prefix=video.name, dir=video.parent) as tmp_dir:
+                tmp_path = Path(tmp_dir) / video_out_path.name
+                self.anonymize_video(video, detection_thresholds, tmp_path, json_out_path)
+                if self.need_to_shutdown:
+                    return
+
+                tmp_path.rename(video_out_path)
+
+            if write_json:
+                json_tar_path = video.with_name(f'{video.name}_jsons.tar.gz')
+                tar = tarfile.open(json_tar_path, "w:gz")
+                tar.add(json_out_path, arcname=f'{video.name}_jsons')
+                tar.close()
+
+            rmtree(json_out_path)
+
+    def anonymize_images(self, input_path, detection_thresholds, all_files, file_types, write_json):
+        files = self.filter_files(all_files, file_types, ".anonymized.png")
+
+        for input_image_path in tqdm(files, desc="Images"):
+            output_image_path = video.with_suffix(".anonymized.png")
+            output_detections_path = video.with_suffix('.json')
+            if output_image_path.exists():
+                continue
 
-            # Anonymize image
             image = load_np_image(str(input_image_path))
-            anonymized_image, detections = self.anonymize_image(image=image, detection_thresholds=detection_thresholds)
-            save_np_image(image=anonymized_image, image_path=str(output_image_path))
+
+            if (output_detections_path).exists():
+                detections = load_detections(detections_path=str(output_detections_path))
+            else:
+                detections = self.anonymize_image(image=image, detection_thresholds=detection_thresholds)
+
+            image = self.blur(image, detections)
+            save_np_image(image, output_image_path)
             if write_json:
                 save_detections(detections=detections, detections_path=str(output_detections_path))
+
+            if self.need_to_shutdown:
+                break
diff --git a/anonymizer/bin/anonymize.py b/anonymizer/bin/anonymize.py
index 4dbf18c..31c5541 100644
--- a/anonymizer/bin/anonymize.py
+++ b/anonymizer/bin/anonymize.py
@@ -21,6 +21,9 @@
 from anonymizer.detection import Detector, download_weights, get_weights_path
 from anonymizer.obfuscation import Obfuscator
 
+import tensorflow
+import os
+
 
 def parse_args():
     parser = argparse.ArgumentParser(
@@ -29,16 +32,15 @@ def parse_args():
                         metavar='/path/to/input_folder',
                         help='Path to a folder that contains the images that should be anonymized. '
                              'Images can be arbitrarily nested in subfolders and will still be found.')
-    parser.add_argument('--image-output', required=True,
-                        metavar='/path/to/output_foler',
-                        help='Path to the folder the anonymized images should be written to. '
-                             'Will mirror the folder structure of the input folder.')
     parser.add_argument('--weights', required=True,
                         metavar='/path/to/weights_foler',
                         help='Path to the folder where the weights are stored. If no weights with the '
                              'appropriate names are found they will be downloaded automatically.')
-    parser.add_argument('--image-extensions', required=False, default='jpg,png',
-                        metavar='"jpg,png"',
+    parser.add_argument('--image-extensions', required=False, default='jpg,jpeg,png,bmp,JPG,JPEG,PNG,BMP',
+                        metavar='"jpg,png,bmp,jpeg"',
+                        help='Comma-separated list of file types that will be anonymized')
+    parser.add_argument('--video-extensions', required=False, default='mp4,mkv,MP4,MKV',
+                        metavar='"mp4,mkv"',
                         help='Comma-separated list of file types that will be anonymized')
     parser.add_argument('--face-threshold', type=float, required=False, default=0.3,
                         metavar='0.3',
@@ -51,37 +53,24 @@ def parse_args():
     parser.add_argument('--write-detections', dest='write_detections', action='store_true')
     parser.add_argument('--no-write-detections', dest='write_detections', action='store_false')
     parser.set_defaults(write_detections=True)
-    parser.add_argument('--obfuscation-kernel', required=False, default='21,2,9',
-                        metavar='kernel_size,sigma,box_kernel_size',
-                        help='This parameter is used to change the way the blurring is done. '
-                             'For blurring a gaussian kernel is used. The default size of the kernel is 21 pixels '
-                             'and the default value for the standard deviation of the distribution is 2. '
-                             'Higher values of the first parameter lead to slower transitions while blurring and '
-                             'larger values of the second parameter lead to sharper edges and less blurring. '
-                             'To make the transition from blurred areas to the non-blurred image smoother another '
-                             'kernel is used which has a default size of 9. Larger values lead to a smoother '
-                             'transition. Both kernel sizes must be odd numbers.')
     args = parser.parse_args()
 
     print(f'input: {args.input}')
-    print(f'image-output: {args.image_output}')
     print(f'weights: {args.weights}')
     print(f'image-extensions: {args.image_extensions}')
+    print(f'video-extensions: {args.video_extensions}')
     print(f'face-threshold: {args.face_threshold}')
     print(f'plate-threshold: {args.plate_threshold}')
     print(f'write-detections: {args.write_detections}')
-    print(f'obfuscation-kernel: {args.obfuscation_kernel}')
     print()
 
     return args
 
 
-def main(input_path, image_output_path, weights_path, image_extensions, face_threshold, plate_threshold,
-         write_json, obfuscation_parameters):
+def main(input_path, weights_path, image_extensions, video_extensions, face_threshold, plate_threshold,
+         write_json):
     download_weights(download_directory=weights_path)
 
-    kernel_size, sigma, box_kernel_size = obfuscation_parameters.split(',')
-    obfuscator = Obfuscator(kernel_size=int(kernel_size), sigma=float(sigma), box_kernel_size=int(box_kernel_size))
     detectors = {
         'face': Detector(kind='face', weights_path=get_weights_path(weights_path, kind='face')),
         'plate': Detector(kind='plate', weights_path=get_weights_path(weights_path, kind='plate'))
@@ -90,15 +79,35 @@ def main(input_path, image_output_path, weights_path, image_extensions, face_thr
         'face': face_threshold,
         'plate': plate_threshold
     }
+
+    obfuscator = None
+    if tensorflow.test.gpu_device_name():
+        print("GPU detected, using that to blur")
+        obfuscator = Obfuscator(kernel_size=21, sigma=0.2, box_kernel_size=9)
+    else:
+        print("No GPU detected, blurring with imagemagick on CPU")
+
+    all_files = {}
+    for (dirpath, dirnames, filenames) in os.walk(input_path):
+        for file in filenames:
+            all_files[os.path.join(dirpath, file)] = True
+        for dirname in dirnames:
+            if dirname.endswith("_jsons"):
+                dirnames.remove(dirname)
+
     anonymizer = Anonymizer(obfuscator=obfuscator, detectors=detectors)
-    anonymizer.anonymize_images(input_path=input_path, output_path=image_output_path,
+    anonymizer.anonymize_images(input_path=input_path, all_files=all_files,
                                 detection_thresholds=detection_thresholds, file_types=image_extensions.split(','),
                                 write_json=write_json)
 
+    anonymizer.anonymize_videos(input_path=input_path, all_files=all_files,
+                                detection_thresholds=detection_thresholds, file_types=video_extensions.split(','), write_json=write_json)
+
 
 if __name__ == '__main__':
     args = parse_args()
-    main(input_path=args.input, image_output_path=args.image_output, weights_path=args.weights,
+    main(input_path=args.input, weights_path=args.weights,
          image_extensions=args.image_extensions,
+         video_extensions=args.video_extensions,
          face_threshold=args.face_threshold, plate_threshold=args.plate_threshold,
-         write_json=args.write_detections, obfuscation_parameters=args.obfuscation_kernel)
+         write_json=args.write_detections)
diff --git a/anonymizer/detection/detector.py b/anonymizer/detection/detector.py
index 56ce2e5..6b5f135 100644
--- a/anonymizer/detection/detector.py
+++ b/anonymizer/detection/detector.py
@@ -10,14 +10,14 @@ def __init__(self, kind, weights_path):
 
         self.detection_graph = tf.Graph()
         with self.detection_graph.as_default():
-            od_graph_def = tf.GraphDef()
-            with tf.gfile.GFile(weights_path, 'rb') as fid:
+            od_graph_def = tf.compat.v1.GraphDef()
+            with tf.io.gfile.GFile(weights_path, 'rb') as fid:
                 serialized_graph = fid.read()
                 od_graph_def.ParseFromString(serialized_graph)
                 tf.import_graph_def(od_graph_def, name='')
 
-        conf = tf.ConfigProto()
-        self.session = tf.Session(graph=self.detection_graph, config=conf)
+        conf = tf.compat.v1.ConfigProto()
+        self.session = tf.compat.v1.Session(graph=self.detection_graph, config=conf)
 
     def _convert_boxes(self, num_boxes, scores, boxes, image_height, image_width, detection_threshold):
         assert detection_threshold >= 0.001, 'Threshold can not be too close to "0".'
diff --git a/requirements.txt b/requirements.txt
index 4191dc6..a41ee02 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,9 +1,11 @@
 pytest==3.9.1
 flake8==3.5.0
 numpy==1.15.2
-tensorflow-gpu==1.11.0
+tensorflow==1.15.5
 scipy==1.1.0
 Pillow==5.3.0
 requests==2.20.0
 googledrivedownloader==0.3
 tqdm==4.28.0
+imageio
+imageio-ffmpeg
-- 
2.30.2

